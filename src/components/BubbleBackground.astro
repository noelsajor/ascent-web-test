---
interface Props {
  interactive?: boolean;
}

const { interactive = true } = Astro.props;
---

<div class="bubble-background-container" data-interactive={interactive}>
  <canvas class="bubble-canvas"></canvas>
  <div class="bubble-content">
    <slot />
  </div>
</div>

<style>
  .bubble-background-container {
    position: relative;
    width: 100%;
    min-height: 70vh;
    background: var(--bg-0);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .bubble-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
  }

  .bubble-content {
    position: relative;
    z-index: 1;
    width: 100%;
  }
</style>

<script>
  class Bubble {
    x: number = 0;
    y: number = 0;
    radius: number = 0;
    speedY: number = 0;
    speedX: number = 0;
    opacity: number = 0;
    wobble: number = 0;
    wobbleSpeed: number = 0;
    wobbleOffset: number = 0;
    width: number;
    height: number;

    constructor(width: number, height: number) {
      this.width = width;
      this.height = height;
      this.reset();
    }

    reset() {
      this.x = Math.random() * this.width;
      this.y = this.height + Math.random() * 100;
      this.radius = Math.random() * 3 + 1;
      this.speedY = Math.random() * 0.5 + 0.3;
      this.speedX = (Math.random() - 0.5) * 0.3;
      this.opacity = Math.random() * 0.15 + 0.05;
      this.wobble = Math.random() * 0.02;
      this.wobbleSpeed = Math.random() * 0.02 + 0.01;
      this.wobbleOffset = Math.random() * Math.PI * 2;
    }

    update(deltaTime: number, mouseX: number, mouseY: number, interactive: boolean) {
      this.y -= this.speedY * deltaTime * 0.06;
      this.wobbleOffset += this.wobbleSpeed * deltaTime * 0.001;
      this.x += Math.sin(this.wobbleOffset) * this.wobble * deltaTime * 0.06;

      if (interactive) {
        const dx = this.x - mouseX;
        const dy = this.y - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = 120;

        if (distance < minDistance) {
          const force = (minDistance - distance) / minDistance;
          this.x += (dx / distance) * force * 0.5;
          this.y += (dy / distance) * force * 0.5;
        }
      }

      if (this.y < -20 || this.x < -20 || this.x > this.width + 20) {
        this.reset();
      }
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(233, 208, 144, ${this.opacity})`;
      ctx.fill();
    }
  }

  function init() {
    const containers = document.querySelectorAll('.bubble-background-container');
    
    containers.forEach(container => {
      const canvas = container.querySelector('.bubble-canvas') as HTMLCanvasElement;
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      const interactive = container.getAttribute('data-interactive') === 'true';
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      let width: number, height: number, bubbles: Bubble[] = [], mouseX = 0, mouseY = 0, animationFrameId: number;

      function resizeCanvas() {
        width = (container as HTMLElement).offsetWidth;
        height = (container as HTMLElement).offsetHeight;
        canvas.width = width;
        canvas.height = height;
      }

      function initBubbles() {
        bubbles = [];
        const isMobile = window.innerWidth < 768;
        const density = isMobile ? 12000 : 8000;
        const bubbleCount = Math.floor((width * height) / density);
        for (let i = 0; i < bubbleCount; i++) {
          bubbles.push(new Bubble(width, height));
        }
      }

      let lastTime = 0;
      let isVisible = true;

      const observer = new IntersectionObserver((entries) => {
        isVisible = entries[0].isIntersecting;
      }, { threshold: 0.1 });

      observer.observe(container);

      function animate(currentTime: number) {
        if (!isVisible) {
          animationFrameId = requestAnimationFrame(animate);
          return;
        }

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        ctx!.clearRect(0, 0, width, height);

        bubbles.forEach(bubble => {
          if (!prefersReducedMotion) {
            bubble.update(deltaTime, mouseX, mouseY, interactive);
          }
          bubble.draw(ctx!);
        });

        animationFrameId = requestAnimationFrame(animate);
      }

      const handleMouseMove = (e: MouseEvent) => {
        if (!interactive) return;
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
      };

      if (interactive) {
        window.addEventListener('mousemove', handleMouseMove);
      }

      resizeCanvas();
      initBubbles();
      animate(0);

      let resizeTimeout: any;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          resizeCanvas();
          initBubbles();
        }, 250);
      });
    });
  }

  // Run on page load and on view transitions
  init();
  document.addEventListener('astro:after-swap', init);
</script>
